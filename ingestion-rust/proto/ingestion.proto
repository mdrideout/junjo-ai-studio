syntax = "proto3";

package ingestion;

option go_package = ".;proto_gen";

// InternalIngestionService provides an API for the main backend to read
// spans from the SQLite WAL.
service InternalIngestionService {
  // ReadSpans reads a batch of spans from the WAL, starting after the
  // specified ULID. This is a server-streaming RPC.
  rpc ReadSpans(ReadSpansRequest) returns (stream ReadSpansResponse) {}

  // GetWALSpansArrow returns spans from WAL as Arrow IPC bytes.
  // Supports filtering by trace_id, service_name, root_only, and workflow_only.
  // Used for unified DataFusion queries combining WAL and Parquet data.
  rpc GetWALSpansArrow(GetWALSpansArrowRequest) returns (stream ArrowBatch) {}

  // GetHotSpansArrow returns only HOT tier spans (since last warm snapshot).
  // This is the three-tier architecture query that returns only the newest data.
  rpc GetHotSpansArrow(GetHotSpansArrowRequest) returns (stream ArrowBatch) {}

  // GetWarmCursor returns the current warm snapshot cursor state.
  // Used by Python to know what's in warm tier vs hot tier.
  rpc GetWarmCursor(GetWarmCursorRequest) returns (GetWarmCursorResponse) {}

  // GetWALDistinctServiceNames returns all distinct service names currently in the WAL.
  // Used to merge with Parquet-indexed services for complete listing.
  // DEPRECATED: Use GetHotSpansArrow + DataFusion instead.
  rpc GetWALDistinctServiceNames(GetWALDistinctServiceNamesRequest) returns (GetWALDistinctServiceNamesResponse) {}

  // FlushWAL triggers an immediate flush of WAL data to Parquet files.
  rpc FlushWAL(FlushWALRequest) returns (FlushWALResponse) {}
}

// ReadSpansRequest defines the parameters for requesting a batch of spans.
message ReadSpansRequest {
  // The ULID of the last span successfully processed by the client.
  // The server will return spans that were received *after* this key.
  // If empty, the stream will start from the oldest available span.
  bytes start_key_ulid = 1;

  // The maximum number of spans to return in the batch.
  uint32 batch_size = 2;
}

// ReadSpansResponse contains a single span from the WAL.
message ReadSpansResponse {
  // The ULID key of the span, which also serves as its timestamp.
  bytes key_ulid = 1;

  // The raw, serialized protobuf bytes of the OTel span.
  bytes span_bytes = 2;

  // The raw, serialized protobuf bytes of the OTel resource.
  bytes resource_bytes = 3;

  // The number of spans remaining in the WAL after this batch was retrieved.
  // This count is decremented atomically when the batch is read.
  uint64 remaining_count = 4;
}

// ============================================================================
// WAL Query Messages (Arrow IPC for unified DataFusion queries)
// ============================================================================

// GetWALSpansArrowRequest filters spans returned as Arrow IPC.
// All filters are optional - omit or leave empty to not filter.
message GetWALSpansArrowRequest {
  // Filter by trace ID (exact match)
  optional string trace_id = 1;

  // Filter by service name (exact match)
  optional string service_name = 2;

  // Only return root spans (parent_span_id is empty)
  bool root_only = 3;

  // Only return workflow spans (junjo.span_type = 'workflow')
  bool workflow_only = 4;

  // Maximum number of spans to return (0 = no limit)
  int32 limit = 5;
}

// ArrowBatch contains Arrow IPC bytes for efficient columnar data transfer.
message ArrowBatch {
  // Arrow IPC record batch bytes (serialized with ipc.NewWriter)
  bytes ipc_bytes = 1;

  // Number of rows in this batch
  int32 row_count = 2;

  // True if this is the last batch in the stream
  bool is_last = 3;
}

// ============================================================================
// Three-Tier Architecture Messages (Hot/Warm/Cold)
// ============================================================================

// GetHotSpansArrowRequest requests only HOT tier spans (since last warm snapshot).
// This is more efficient than GetWALSpansArrow as it excludes data already in warm snapshots.
message GetHotSpansArrowRequest {
  // Only return spans newer than this ULID.
  // If empty/null, returns ALL spans in SQLite (fallback when no warm snapshots exist).
  optional bytes since_warm_ulid = 1;

  // Filter by trace ID (exact match)
  optional string trace_id = 2;

  // Filter by service name (exact match)
  optional string service_name = 3;

  // Only return root spans (parent_span_id is empty)
  bool root_only = 4;

  // Only return workflow spans (junjo.span_type = 'workflow')
  bool workflow_only = 5;

  // Maximum number of spans to return (0 = no limit)
  int32 limit = 6;
}

// GetWarmCursorRequest requests the current warm snapshot cursor state.
message GetWarmCursorRequest {
  // Empty - no parameters needed
}

// GetWarmCursorResponse contains the warm snapshot cursor state.
message GetWarmCursorResponse {
  // Last span ULID written to warm snapshot (empty if no snapshots)
  bytes last_warm_ulid = 1;

  // Timestamp of last warm snapshot in nanoseconds
  int64 last_warm_time_ns = 2;

  // Number of warm parquet files currently in tmp/
  int32 warm_file_count = 3;
}

// GetWALDistinctServiceNamesRequest requests all distinct service names in WAL.
// DEPRECATED: Use GetHotSpansArrow + DataFusion instead.
message GetWALDistinctServiceNamesRequest {
  // Empty - no parameters needed
}

// GetWALDistinctServiceNamesResponse contains the list of service names.
message GetWALDistinctServiceNamesResponse {
  repeated string service_names = 1;
}

// FlushWALRequest triggers a manual WAL flush.
message FlushWALRequest {}

// FlushWALResponse contains the result of a flush operation.
message FlushWALResponse {
  bool success = 1;
  string error_message = 2;  // Error details if success=false
}
